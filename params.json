{
  "name": "rocoofix原理",
  "tagline": "\b笔记",
  "body": "class.dex |class1.dex |\r\n---|---\r\na.class |d.class |\r\nb.class[有bug] |e.class|\r\nc.class |f.class|\r\n.... |...|\r\n \r\n1：下面分析android是如何加载class的，比如b.class\r\n> 核心代码\r\n> https://android.googlesource.com/platform/libcore-snapshot/+/ics-mr1/dalvik/src/main/java/dalvik/system/DexPathList.java\r\n\r\n```\r\n  public Class findClass(String name) {\r\n        //dexElements [class.dex,class1.dex.....]\r\n        for (Element element : dexElements) {\r\n            DexFile dex = element.dexFile;\r\n            if (dex != null) {\r\n                Class clazz = dex.loadClassBinaryName(name, definingContext);\r\n                if (clazz != null) {\r\n                    return clazz;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    //可以看到是按照dexElements数组里面的dex文件顺序循环，第一个成功找到并返回\r\n```\r\n那么我们hack上面这个查找过程，新增补丁dex\r\n补丁.dex |class.dex |class1.dex |\r\n---|---|---\r\n无 |a.class |d.class |\r\nb.class[补丁]  |b.class[有bug] |e.class|\r\n无  |c.class |f.class|\r\n无 |...|\r\n\r\n```\r\n        ....\r\n  //dexElements [补丁.dex,class.dex,class1.dex.....]\r\n  //加入补丁.dex，并放到数组最前面，那么就会首先查找补丁.dex的类\r\n        for (Element element : dexElements) {\r\n        ....\r\n```\r\n2：成功插入了补丁的class,但是下面的情况会出问题\r\n\r\n```\r\n报错：java.lang.IllegalAccessError: Class ref in pre-verified class\r\n场景：c.class调用b.class\r\n现在是 c.class[class.dex]---->b.class[补丁.dex]  不同dex中，报错\r\n原先是c.class[class.dex]---->b.class[class.dex]  同一个dex中,不报错\r\n```\r\n\r\n```\r\n错误原因：被打上CLASS_ISPREVERIFIED标签的类会进行校验。\r\n报错源代码：\r\nhttps://android.googlesource.com/platform/dalvik.git/+/51801371a9b0f829303d326a2300518177dde3e8/vm/oo/Resolve.cpp\r\nif (!fromUnverifiedConstant &&\r\n            IS_CLASS_FLAG_SET(referrer, CLASS_ISPREVERIFIED))\r\n        {\r\n            ClassObject* resClassCheck = resClass;\r\n            if (dvmIsArrayClass(resClassCheck))\r\n                resClassCheck = resClassCheck->elementClass;\r\n            if (referrer->pDvmDex != resClassCheck->pDvmDex &&\r\n                resClassCheck->classLoader != NULL)\r\n            {\r\n                ALOGW(\"Class resolved by unexpected DEX:\"\r\n                     \" %s(%p):%p ref [%s] %s(%p):%p\",\r\n                    referrer->descriptor, referrer->classLoader,\r\n                    referrer->pDvmDex,\r\n                    resClass->descriptor, resClassCheck->descriptor,\r\n                    resClassCheck->classLoader, resClassCheck->pDvmDex);\r\n                ALOGW(\"(%s had used a different %s during pre-verification)\",\r\n                    referrer->descriptor, resClass->descriptor);\r\n                dvmThrowIllegalAccessError(\r\n                    \"Class ref in pre-verified class resolved to unexpected \"\r\n                    \"implementation\");\r\n                return NULL;\r\n            }\r\n        }\r\n\r\n解决办法：防止类被打上CLASS_ISPREVERIFIED标签\r\n\r\n1：那么类是什么时候被打上CLASS_ISPREVERIFIED标签的\r\nhttps://android.googlesource.com/platform/dalvik/+/froyo-release/vm/analysis/DexVerify.c\r\nif (dvmVerifyClass(clazz, VERIFY_DEFAULT)) {\r\n    //校验通过则写入CLASS_ISPREVERIFIED标签\r\n                    assert((clazz->accessFlags & JAVA_FLAGS_MASK) ==\r\n                        pClassDef->accessFlags);\r\n                    ((DexClassDef*)pClassDef)->accessFlags |=\r\n                        CLASS_ISPREVERIFIED;//加入标签\r\n                }\r\n                \r\n2：如何防止被打上标签\r\n原理：让校验不通过\r\n如果a.class 引用了不在同一个dex文件中的class,那么a.class就不会有CLASS_ISPREVERIFIED\r\n上面c.class开始和b.class在同一个dex,所以c.class被打上标签\r\n 后面补丁的b.class和c.class不在同一个dex,所以报错，为了解决这个问题\r\n 我们要事先就要防止a.class被打上标签\r\n\r\n3 方法：\r\n使用gralde插件，编译阶段在a.class的构造函数中插入(通过字节码修改库asm)\r\nHack.class的引用，hack.class在独立的dex文件中，那么a.class的标签就不会打上\r\n```\r\n\r\n\r\n```\r\nhttps://github.com/dodola/RocooFix 实现了上面方案的开源库\r\n```\r\n```\r\nrocoo 解决类加载问题核心代码\r\n   Field pathListField = RocooUtils.findField(loader, \"pathList\");\r\n            Object dexPathList = pathListField.get(loader);\r\n            Field dexElement = RocooUtils.findField(dexPathList, \"dexElements\");\r\n            Class<?> elementType = dexElement.getType().getComponentType();\r\n            Method loadDex = RocooUtils.findMethod(dexPathList, \"loadDexFile\", File.class, File.class, ClassLoader.class, dexElement.getType());\r\n            loadDex.setAccessible(true);\r\n\r\n            Object dex = loadDex.invoke(null, additionalClassPathEntries.get(0), optimizedDirectory, loader, dexElement.get(dexPathList));\r\n            Constructor<?> constructor = elementType.getConstructor(File.class, boolean.class, File.class, DexFile.class);\r\n            constructor.setAccessible(true);\r\n            Object element = constructor.newInstance(new File(\"\"), false, additionalClassPathEntries.get(0), dex);\r\n\r\n            Object[] newEles = new Object[1];\r\n            newEles[0] = element;\r\n            RocooUtils.expandFieldArray(dexPathList, \"dexElements\", newEles);\r\n```\r\n\r\n\r\n```\r\nrocoofix 插件，解决CLASS_ISPREVERIFIED 问题 核心代码\r\nv.visitFieldInsn(Opcodes.GETSTATIC, \"java/lang/Boolean\", \"FALSE\", \"Ljava/lang/Boolean;\");\r\n        v.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/Boolean\", \"booleanValue\", \"()Z\", false);\r\n        v.visitJumpInsn(Opcodes.IFEQ, l1);\r\n        v.visitFieldInsn(Opcodes.GETSTATIC, \"java/lang/System\", \"out\", \"Ljava/io/PrintStream;\");\r\n        v.visitLdcInsn(Type.getType(\"Lcom/dodola/rocoo/Hack;\"));\r\n        v.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/io/PrintStream\", \"println\", \"(Ljava/lang/Object;)V\", false);\r\n        v.visitLabel(l1);\r\n```\r\n\r\n```\r\n参考\r\n1空间的文章https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&mid=400118620&idx=1&sn=b4fdd5055731290eef12ad0d17f39d4a&scene=1&srcid=1106Imu9ZgwybID13e7y2nEi#wechat_redirect  感谢qqzone\r\n2https://github.com/dodola/RocooFix 感谢dodola\r\n```",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}